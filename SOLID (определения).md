S - Single responsibility principle:
	Каждый модуль отвечает за 1 актора (выполняет только 1 задачу)

O - Open/closed principle:
	Сущности должны быть открыты для расширения, закрыты для изменения. Новая функциональность вводится путем добавления нового кода, а не изменением старого, уже работающего (сокрытие, организация иерархии модулей, изоляция бизнес логики, наследование для сокрытия/инкапсуляции функционала)
	`поведение наследующих классов не должно противоречить поведению базового класса

L - Liskov substitution:
	Использование правильного наследования, сущности не должны зависеть от интерфейсов которые они НЕ используют, все сущности должны одинаково проходить тест для интерфейса (проблема квадрат, прямоугольник)

I - Interface segregation principle:
	Абстракции не должны зависеть от имплементаций, имплементации должны зависеть от абстракций (для каждого актора отдельный интерфейс, несмотря на общую реализацию), позволяет избежать непреднамеренных зависимостей (противоречит принципу dry)

D - Dependency injection principle:
	самые гибкие системы это системы, которые ссылаются на абстракции, вместо реализаций. В языках со ст, сделать легче, т. к. все построено на абстракциях, но и в дт языках должны быть ограничения импорта/экспорта реализаций. В некоторых случаях, невозможно сослаться на абстрактную реализацию, например класс String в Java. Тогда мы игнорируем фундамент без абстракций. Изменения реализации не влияют на абстракцию, в то время как изменение абстракции влияют как на абстракцию, так и на реализацию. => интерфейсы менее изменчивы, чем реализации (оно и понятно, учитывая ограничения языка)